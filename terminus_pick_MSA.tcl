#CODE TO PICK THE TERMINUS LINE FROM THE WTMM OUTPUT#LAST MODIFIED BY JUKES LIU 6-13-2020#ORDER: MOD, SIZE, ARG#input variablesputs "Thresholds entered: $argv"set size_percentile [lindex $argv 0]set mod_percentile [lindex $argv 1]set arg_frac_thresh [lindex $argv 2]#PRESETS:#set paths and time and date of the run#set basepath /home/jukes/Documents/Sample_glaciersset basepath /media/jukes/jukes1/LS8aws# requires a file from this cppPATHset cppPATH /home/jukes/Documents/2017_05_19set clocktime [clock format [clock seconds] -format "%T"]set clockdate [clock format [clock seconds] -format "%Y_%m_%d"]#set value for piset pi [expr {acos(-1)}]#set percentile thresholds and arg (orientation) buffer around North and Southset arg_buffer [expr $pi/3]set arg_buff2 [expr $pi/3]#set arg_frac_thresh 0.3set ratio_limit 1.35#set not between functionproc notbetween {{value} {minimum} {maximum}} {    expr {$value <= $minimum || $maximum <= $value}}set use_mass 1set use_size 0#CREATE NEW OUTPUT FOLDER NAME AND CREATE .CSV FILE TO HOLD PRINTED OUTPUTset newfolder Datfilesset logfilename terminuspicks_${clockdate}.csvset outputfile [open /home/jukes/Documents/Sample_glaciers/${logfilename} w]puts $outputfile "$clocktime"puts $outputfile "BoxID,Scene,Scale,Metric,Order,"#Grab BoxIDsset BoxIDs [lrange $argv 3 end]#For each glacier in the listforeach BoxID $BoxIDs {    #set the path to the images and masks    set path ${basepath}/Box${BoxID}/rotated_c1    #make BoxID folder to hold .jpeg, .asc, and .pgm files    #if the folder exists already, delete the old folder    if ([file exists ${basepath}/$newfolder/Box${BoxID}]) {	#remove old folder	file delete -force ${basepath}/$newfolder/Box${BoxID}	puts "Old Box$BoxID folder removed."    }        file mkdir ${basepath}/$newfolder/Box${BoxID}    #set the terminus box mask and iload    #set ima_mask ${path}/crop_Box${BoxID}_raster_cut.pgm    set ima_mask ${path}/R_Box${BoxID}_raster_cut.pgm    iload $ima_mask mask -pgm8bit    #get box mask raster size    set mask_info [iinfo mask]    set mask_x [lindex $mask_info 1]    set mask_y [lindex $mask_info 2]    #set threshold for masking to be between the min and mask (average) , which should be 0     set min [lindex $mask_info 3]    set max [lindex $mask_info 4]    set thresh [expr ($max + $min)/2]    #puts "threshold value should be 0: $thresh"        #SET THE LIST OF IMAGES FROM THE FOLDER    set ima_list [glob -dir $path "*${BoxID}.pgm"]    #set ima_list ${path}crop_R_LC80340052015138LGN00_B8_PS_Buffer001.pgm        #total number of images processed:    set num_images [llength $ima_list]        #set total fail counter for number of images processed that have no output    set total_fails 0    set img_counter 0    #set training match to 0    set data_match 0        foreach ima_original $ima_list {		set ID_length [string length $BoxID]	set img_name_idx [expr 44 + $ID_length-3]	set img_name [string range $ima_original $img_name_idx end]	set scene_name [string range $img_name 0 20]	        # #LOOP THROUGH TRAINING DATA TO SEE WHICH IMAGES TO PROCEED WITH	# foreach line $data {	#     set data_BoxID [string range $line 0 2]	#     set data_scene [string range $line end-20 end]	#     if {$BoxID == $data_BoxID & $scene_name == $data_scene} {	#        puts $data_scene	#        set data_match 1	#     }	# }	set data_match 1	#if the image is a match with the training set, proceed	if {$data_match == 1} {	    #Proceed	    #load the original image	    #iload ${ima_original} $ima_original -pgm16bit -swap_bytes	    iload ${ima_original} $ima_original -pgm8bit	    puts "$img_name"	    incr img_counter	    #make a new efiltered folder	    #if the file exists, delete the old folder	    if ([file exists ${ima_original}_max_gaussian/${newfolder}]) {		file delete -force ${ima_original}_max_gaussian/${newfolder}		puts "Old $newfolder folder removed."	    }	    file mkdir ${ima_original}_max_gaussian/${newfolder}	    #set lists for sizes and mods and posfirsts and scales that passed the tests:	    set posfirstList {}	    set posfirstindex {}	    set size_list {}	    set mod_list {}	    set scale_list {}	    set scale_unf {}	    	    set use_metric 1	    	    #at each scale, load the ext image as e	    for {set sca 0} {$sca < 50} {incr sca +1} {		set scaF [format "%.3d" $sca]		eload ${ima_original}_max_gaussian/max$scaF e				#EMASK2 ALL THE CHAINS OUTSIDE OF THE MASK		emask2 e mask $thresh emasked_$scaF		hsearch emasked_$scaF		#find the number of chains in the emasked ext iamge		set ext_info [einfo emasked_$scaF]		set num_chains [lindex $ext_info 5]		#dputs "number of chains after masking: $num_chains"		#if there are no chains left after emasking:		if {$num_chains == 0} {		    puts "no chains left after emasking"		    #do nothing		    		    #IF THERE CHAINS, CONTINUE WITH FILTERING:		} else {    		    #GRAB SIZE THRESHOLD		    set size_max 0		    set mod_max 0		    #Grab maximum size		    eilineloop emasked_$scaF {			#  grab the maximum chain size and linemeanmod in the image			if {$size > $size_max} {			    set size_max [format "%.10f" $size]			}			#if low contrast across centerline, grab the max mod here			if {$use_metric == 2} {			    if {$linemeanmod > $mod_max} {				set mod_max [format "%.5f" $linemeanmod]			    }			}		    }		    #SET THRESHOLD VALUES FOR SIZE AND ARG		    #set size threshold based on size_percentile		    set size_thresh [format "%.0f" [expr $size_max*$size_percentile]]		    #set arg thresholds from arg_buffer at top of script		    set north [expr $pi/2]		    set south [expr -1.0*$pi/2]		    		    set NE [format "%.10f" [expr $north-$arg_buffer]]		    set NW [format "%.10f" [expr $north+$arg_buffer]]		    set SE [format "%.10f" [expr $south+$arg_buffer]]		    set SW [format "%.10f" [expr $south-$arg_buffer]]		    #dputs "arg thresholds: NE $arg_thresh_NE, NW $arg_thresh_NW, SE $arg_thresh_SE, SW $arg_thresh_SW"		    #if there is high contrast across centerline, grab max mod from those lines that passed the size test		    if {$use_metric == 1} {			#set empty list for mod thresh calculation			set mod_passedsize {}						#Grab mods for lines passing the size and non-closed test			eilineloop emasked_$scaF {			    #if the line is not closed, continue			    if {$closed == 0} {				#if size is above the threshold, continue				if {$size > $size_thresh} {				    lappend mod_passedsize [format "%.5f" $linemeanmod]				}			    }			}			#puts "$mod_passedsize"						#Grab maximum linemeanmod out of those that passed the size test			foreach mod_passed $mod_passedsize {			    #calculate mod_thresh from the remaining lines			    if {$mod_passed > $mod_max} {				set mod_max [format "%.5f" $mod_passed]			    }			}		    }		    #set mod threshold based on mod_percentile		    set mod_thresh [format "%.0f" [expr $mod_max*$mod_percentile]]		    #set counter for number of lines that pass at each scale		    set passedthresh 0		    #EILINELOOP TO THRESHOLD AND KEEP THOSE CHAINS THAT PASS THE TESTS		    eilineloop emasked_$scaF {			#if line is not closed, contiue			if {$closed == 0} {			    if {$linemeanmod > $mod_thresh} {				#if size is above threshold:				if {$size > $size_thresh} {				    #puts "Scale $scaF, $size passed size thresh $size_thresh, mod $linemeanmod, mod_thresh: $mod_thresh"				    #grab the arguments for each line				    #translate posfirst to x, y and change line to signal				    set y [expr $posfirst/$mask_x]				    set x [expr $posfirst - $y*$mask_x]				    l2s emasked_$scaF s_mod $x $y -arg s_arg				    				    set avg_arg 0				    set arg_counter 0				    set arg_passcounter 0				    				    #find number of args in the signal that are not N or S, use $y to refer to arg:				    foreachs s_arg {					incr arg_counter					if {[notbetween $y $NE $NW] && [notbetween $y $SW $SE]} {					    incr arg_passcounter					}				    }				    				    #find the fraction of arguments that were left or right (passed)				    set arg_passfrac [expr double($arg_passcounter)/double($arg_counter)]				    puts "Scale $scaF, Size: $size, Mod: $linemeanmod, Arg_frac: $arg_passfrac"				    #LOWER THE ARG_FRAC THRESHOLD FOR THOSE LINES AT LOWER SCALES (more likely to contain a fjord wall)				    #set unformatted scale by removing 0s with trmileft				    #set scale [expr [string trimleft $scaF 0] + 1]				    #set increment to lower the arg threshold by (maximum of 0.2)				    #set arg_frac_incr [expr 0.2/50]				    #set arg_thresh_lower [expr (50-$scale)*$arg_frac_incr]				    #set new_argthresh [expr $arg_frac_thresh-$arg_thresh_lower]				    #puts "Arg threshold after adjusting for size: $new_argthresh"				    #if the fraction > 65% then, save the line details				    #if {$arg_passfrac > $new_argthresh} {}				    if {$arg_passfrac > $arg_frac_thresh} {					lappend posfirstList $posfirst					lappend posfirstindex 0					lappend size_list $size					lappend mod_list $linemeanmod					lappend scale_list $scaF					lappend scale_unf $sca					incr passedthresh				    }				    #end of mod if				}				#end of arg if			    }			    #end of size if			}			#end of closed if		    }		    #END OF EILINELOOP		    #puts "$passedthresh chains passed all tests at scale $scaF"		}		#END OF IF STATEMENT	    }	    #END OF SCALE LOOP, NOW IN JUST IMAGE LOOP	    	    #GRAB TOP 5 LINES WITH HIGHEST MASSES OR SIZES ACROSS ALL SCALES	    set topfive_val {}	    set topfive_index {}	    set topfive_scale {}	    set topfive_posfirst {}	    	    set mass_max 0	    set highestsize 0	    set index_max 0	    set length [llength $size_list]	    #if the length of these lists are 0, then no chains passed the test across all scales for the image	    if {$length == 0} {		puts "No chains passed the test at any scale for the image! Try changing your thresholds."		incr total_fails		#otherwise, grab the top 5!	    } else {		if {$use_mass == 1} {		    #find the lines with the highest 5 scaled  masses by looping through the line lists for the image		    #for each line (must loop backwards)		    for {set i 0} {$i < $length} {incr i +1} {			#grab the posfirst and formatted & unformatted scale			set its_scale [lindex $scale_list [expr $length-$i-1]]			set its_scale_unf [expr double([lindex $scale_unf [expr $length-$i-1]])]			set its_posfirst [lindex $posfirstList [expr $length-$i-1]]			#calculate the mass			set its_size [lindex $size_list [expr $length-$i-1]]			set its_mod [lindex $mod_list [expr $length-$i-1]]			#IMPLEMENTING SCALED MASS: (SIZE*MOD)/log(unformatted scale)			#set mass [format "%.10f" [expr $its_size*(${its_mod}/${binary_scale})]]			set mass [format "%.10f" [expr $its_size*(${its_mod}/pow(2, $its_scale_unf))]]			puts "Scale$its_scale, Scaled Mass: $mass"			#if the mass is greater than the max, set it to the new max, and repeat			#until highest is found in the loop			if {$mass > $mass_max} {			    set mass_max [format "%.10f" $mass]			    #store the index of that line in the lists			    set index_max [expr $length-$i-1]			    #append the mass value and the index value to the last position in the list - PUSH			    lappend topfive_val $mass_max			    lappend topfive_index $index_max			    lappend topfive_scale $its_scale			    lappend topfive_posfirst $its_posfirst			    #if there are more than five values, remove the value of the 1st position in the list - POP			    if {[llength $topfive_val] > 5} {				set topfive_val [lreplace $topfive_val 0 0]				set topfive_index [lreplace $topfive_index 0 0]				set topfive_scale [lreplace $topfive_scale 0 0]				set topfive_posfirst [lreplace $topfive_posfirst 0 0]			    }			    #end of topfive length if			}			#end of mass max if		    }		    #end of loop through lists to find mass max		}		#END OF MASS IF STATEMENT				if {$use_size == 1} {		    # find the line with the highest size from the lists 		    for {set j 0} {$j < $length} {incr j +1} {			#grab the posfirst and scale			set its_scale [lindex $scale_list [expr $length-$j-1]]			set its_posfirst [lindex $posfirstList [expr $length-$j-1]]			#grab size			set its_size [lindex $size_list [expr $length-$j-1]]						#if size is greater than the max, set it to the new max, and repeat			if {$its_size > $highestsize} {			    set highestsize $its_size			    #store the index of that line in the lists			    set index_max [expr $length-$j-1]			    #append the mass value and the index value to the last position in the list - PUSH			    lappend topfive_val $highestsize			    lappend topfive_index $index_max			    lappend topfive_scale $its_scale			    lappend topfive_posfirst $its_posfirst			    #if there are more than five values, remove the value of the 1st position in the list - POP			    if {[llength $topfive_val] > 5} {				set topfive_val [lreplace $topfive_val 0 0]				set topfive_index [lreplace $topfive_index 0 0]				set topfive_scale [lreplace $topfive_scale 0 0]				set topfive_posfirst [lreplace $topfive_posfirst 0 0]			    }			    #end of topfive length if			}			#end of size if		    }		    #end of loop through lists to find highest size		}		#END OF SIZE IF STATEMENT		#Print the top 5 chain info for each image:		puts "Top 5 values: $topfive_val"		#puts "Top 5 indices: $topfive_index"		puts "Scales: $topfive_scale"		#puts "Top 5 posfirsts: $topfive_posfirst"	    }	    #END OF LENGTH IF STATEMENT	    set toplineslength [llength $topfive_val]	    #IF NO CHAINS WERE FOUND AT ANY SCALE, LENGTH OF LIST WILL BE 0	    if {$toplineslength == 0} {		#puts NaNs into .csv file and don't write any .dat files		puts $outputfile "$BoxID,$scene_name,NaN,NaN,NaN,"				#IF SOME WERE FOUND, OUTPUT THE RESULTS	    } else {		#FOR EACH CHAIN IN THE TOP 5 LIST:		for {set k 0} {$k < $toplineslength} {incr k +1} {		    set topscale [lindex $topfive_scale $k]		    set topval [lindex $topfive_val $k]		    set topposfirst [lindex $topfive_posfirst $k]		    set toporder [expr $toplineslength - $k]		    		    # PRINT THE BOXID, IMAGE NAME, SCALE, MASS or SIZE VALUE, AND ORDER  FOR EACH OF THE (UP TO) 5 TO CSV FILE		    puts $outputfile "$BoxID,$scene_name,$topscale,$topval,$toporder,"		    		    #CREATE DAT FILES FOR EACH OF TOP 5 (OR UP TO 5)		    #create the line signals:		    #turn line into arg signal to remove edges		    set final_y [expr $topposfirst/$mask_x]		    set final_x [expr $topposfirst - $final_y*$mask_x]		    #holds mod as x and arg as y		    #create arg signal and xy signal		    l2s emasked_$topscale s_finalmod $final_x $final_y -arg s_finalarg		    l2s emasked_$topscale s_finalmod $final_x $final_y -xy s_xy		    #create list of points in arg signal:		    set arg_list {}		    foreachs s_finalarg {			    			lappend arg_list [expr $y]		    }		    set siglength [llength $arg_list]		    #create lists of points in xy signal		    set x_list {}		    set y_list {}		    foreachs s_xy {			    			lappend x_list [format "%.0f" [expr $x]]			lappend y_list [format "%.0f" [expr $y]]			# lappend x_trimmed [format "%.0f" [expr $x]]			# lappend y_trimmed [format "%.0f" [expr $y]]		    }		    set NE2 [format "%.10f" [expr $north-$arg_buff2]]		    set NW2 [format "%.10f" [expr $north+$arg_buff2]]		    set SE2 [format "%.10f" [expr $south+$arg_buff2]]		    set SW2 [format "%.10f" [expr $south-$arg_buff2]]		    		    #remove those that have bad arg:		    set argflag 0		    set counter 0		    #forward:		    foreach argument $arg_list {			if {$argflag == 0} {								    if {![notbetween $argument $NE2 $NW2] || ![notbetween $argument $SW2 $SE2]} {				#trim it		    			    } else {				set argflag 1				set index_crit_fwd $counter			    }			}			incr counter		    }		    		    # #reverse:		    set arg_rev [lreverse $arg_list]		    set argflag 0 		    set counter 0		    foreach argument $arg_rev {			if {$argflag == 0} {								    if {![notbetween $argument $NE2 $NW2] || ![notbetween $argument $SW2 $SE2]} {				#trim it			    } else {				set argflag 1				set index_crit_rev [expr $siglength-$counter]			    }			}			incr counter		    }		    		    #Get trimmed lists for final terminus signal		    #set arg_trimmed [lrange $arg_list $index_crit_fwd $index_crit_rev]		    set x_trimmed [lrange $x_list $index_crit_fwd $index_crit_rev]		    set y_trimmed [lrange $y_list $index_crit_fwd $index_crit_rev]		    		    #screate final_sig for untrimmed line		    screate final_sig 0 1 0 -xy $topposfirst		    #WRITE FINAL LINES (TRIMMED AND ORIGINAL) TO FILES!		    #write the trimmed terminus line to a dat file		    set outputdatfile [open ${ima_original}_max_gaussian/$newfolder/terminus_trim_${topscale}.dat w]		    for {set i 0} {$i<[llength $x_trimmed]} {incr i} {			puts $outputdatfile "[lindex $x_trimmed $i] [lindex $y_trimmed $i]"		    }		    close $outputdatfile		    #write the original terminus line to a dat file		    eisavelines emasked_${topscale} final_sig terminus_${topscale}		    chains2dat terminus_${topscale} -line ${ima_original}_max_gaussian/$newfolder/terminus_${topscale}.dat		    #write emasked line to dat file		    chains2dat emasked_${topscale} -line ${ima_original}_max_gaussian/$newfolder/emasked_${topscale}.dat		    #SAVE RESULT TO DAT, WTMMM AND VECTORS (FOR SKEL), OVER ORIGINAL IMAGE, TO ASCII, AND TO PGM8BIT				    # #WTMMM and vectors:		    # #	esave efiltered_$scaF ${ima_original}_max_gaussian/$newfolder/WTMMM_efiltered_${scaF}.dat -ascii -pos -vc		    # #	esave efiltered_$scaF ${ima_original}_max_gaussian/$newfolder/arrows_efiltered_${scaF}.dat -ascii -vc		    # #display the lines over original image to check:		    esave terminus_${topscale} ${basepath}/$newfolder/Box${BoxID}/${img_name}_terminus_${topscale}.jpeg -jpeg 5 -bg $ima_original		    #turn dat files into ascii files which are then iloaded and isaved as seglines		    exec ${cppPATH}/dat2ascii_manual_comp ${ima_original}_max_gaussian/$newfolder/terminus_${topscale}.dat ${basepath}/$newfolder/Box${BoxID}/${img_name}_terminus_${topscale}.asc $mask_x $mask_y		    iload ${basepath}/$newfolder/Box${BoxID}/${img_name}_terminus_${topscale}.asc A -ascii		    isave A ${basepath}/$newfolder/Box${BoxID}/${img_name}_terminus_${topscale}.pgm -pgm8bit		    #for emasked		    exec ${cppPATH}/dat2ascii_manual_comp ${ima_original}_max_gaussian/$newfolder/emasked_${topscale}.dat ${basepath}/$newfolder/Box${BoxID}/${img_name}_emasked_${topscale}.asc $mask_x $mask_y		    iload ${basepath}/$newfolder/Box${BoxID}/${img_name}_emasked_${topscale}.asc A -ascii		    isave A ${basepath}/$newfolder/Box${BoxID}/${img_name}_emasked_${topscale}.pgm -pgm8bit		}		#END OF TOP 5 LINES FOR LOOP	    }	    #END OF IF STATMENT	}	#END OF TRAINING DATA IF STATEMENT    }     #END OF IMAGE LOOP}#END OF GLACIER BOXID FOLDER LOOPclose $outputfile